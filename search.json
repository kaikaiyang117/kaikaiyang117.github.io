[{"title":"博客上传指南","path":"/2025/01/06/博客上传指南/","content":"如何上传文章1.创建在博客目录下，打开命令行 1hexo new &quot;文章标题&quot; Hexo 会在source/_posts目录下创建一个新的 Markdown 文件，文件名是根据文章标题生成的，同时会自动添加一些基本的头部信息，如文章的创建日期、标题等。 然后使用markdown编辑文章 2.在本地查看并预览启动本地服务器，运行 1hexo server 访问地址http://localhost:4000,查看在本地的预览效果。 3.部署讲完成的博客,使用 1hexo deploy 部署在github上。 hexo常用指令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本"},{"path":"/2024/12/01/搭建github-hexo博客/检测/","content":"1判断环 1.1 拓扑排序针对无向图： 求出图中所有结点的度。 将所有&#x3D;&#x3D;度&#x3D;&#x3D; &lt;&#x3D; 1 的结点入队。 当队列不空时，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为一，则将相邻结点入队。 循环结束时判断已经访问的结点数是否等于 n。等于 n 说明全部结点都被访问过，无环；反之，则有环。 针对有向图： 求出图中所有结点的度。 将所有&#x3D;&#x3D;入度&#x3D;&#x3D; &#x3D; 0 的结点入队。 当队列不空时，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为一，则将相邻结点入队。 循环结束时判断已经访问的结点数是否等于 n。等于 n 说明全部结点都被访问过，无环；反之，则有环。 仿照拓扑排序 对于有向图的拓扑排序，kahn算法： 计算图中所有点的入度，把入度为0的点加入栈 如果栈非空： 取出栈顶顶点a，输出该顶点值，删除该顶点 从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈 如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列 1.2 DFS：使用 &#x3D;&#x3D;DFS&#x3D;&#x3D; 可以判断一个无向图和有向图中是否存在环。深度优先遍历图，如果在遍历的过程中，发现某个结点有一条边指向已访问过的结点，并且这个已访问过的结点不是上一步访问的结点，则表示存在环。 1.针对有向图： 环的判断需要关注图中是否&#x3D;&#x3D;存在回边&#x3D;&#x3D;，即从某个节点出发又返回到该节点。在DFS过程中，可以使用三种状态来标记节点： **未访问 (0)**：该节点还没有被访问过。 **正在访问 (1)**：该节点正在递归调用过程中，意味着DFS已经进入该节点，但尚未完成该节点的所有邻接点访问。 **已访问 (2)**：该节点及其所有邻接节点的DFS调用都已完成。 在DFS过程中，如果从当前节点的邻接节点出发回到一个正在访问 (1) 状态的节点，说明图中存在环。 针对无向图 对于无向图，环的判断稍微复杂一些，因为无向图的边是双向的，因此在DFS过程中，如果访问到一个已经访问过的节点，并且该节点不是DFS路径的父节点，就说明存在环。 1.3 并查集（Union-Find）并查集是一种用于处理连通性问题的数据结构，常用于无向图的环检测。在图中添加一条边时，使用并查集检查两个端点是否属于同一个集合。 如果两端点已经在同一个集合中，则添加这条边会形成环。 如果不在同一个集合中，则将它们合并。 2.递归建树 2.1 建树12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;struct Node &#123; int data; Node* left; Node* right;&#125;;void Insert(Node*&amp; root, int value) &#123; if (root == nullptr) &#123; root = new Node&#123;value, nullptr, nullptr&#125;; return; &#125; if (value &lt; root-&gt;data) &#123; Insert(root-&gt;left, value); &#125; else &#123; Insert(root-&gt;right, value); &#125;&#125;void Createbstree(Node*&amp; T, int L[], int N) &#123; //针对有序数组 if (N &lt;= 0) return; int mid = N / 2; Insert(T, L[mid]); Createbstree(T, L, mid); Createbstree(T, L + mid + 1, N - mid - 1); //针对无需数组 for (int i = 0; i &lt; N; ++i) &#123; Insert(T, L[i]); &#125;&#125; 2.2 合并二叉排序树123456789void MergeTrees(Node*&amp; T1, Node* T2) &#123; if (T2 == nullptr) return; MergeTrees(T1, T2-&gt;left); Insert(T1, T2-&gt;data); MergeTrees(T1, T2-&gt;right); &#125; void mergebstree(Node*&amp; T1, Node* T2) &#123; MergeTrees(T1, T2);&#125; 3.动态规划3.1抓娃娃 状态转移： 对于 n = 0，只有一种情况（即没有娃娃）。 对于 n = 1，只有一种情况（拿 1 个娃娃）。 对于 n = 2，有两种情况：要么拿两个 1，要么拿一个 2。 对于 n &gt; 2，我们可以通过以下两种方式来考虑： 如果第一次拿了 1 个娃娃，那么剩下的就是 n-1 个娃娃，问题转化为 n-1 的情况。 如果第一次拿了 2 个娃娃，那么剩下的就是 n-2 个娃娃，问题转化为 n-2 的情况。 因此，递推关系式为： ​ $f(n)&#x3D;f(n−1)+f(n−2)$ 其中 f(n) 表示有多少种方式分配 n 个娃娃。 4.贪心算法 题解： 5. 图 使用邻接表表示图，记录每个人被喜欢的次数。 使用 入度数组 来统计每个节点的被喜欢次数。 使用拓扑排序检测并剔除环。环状喜欢链会导致入度无法减少。 遍历 入度数组，找出被喜欢度最大的节点。 如果有多个节点被喜欢度相同，按字典序输出。 6 .链表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode &#123; int val; struct ListNode* next; struct ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;struct ListNode* createNode(int val) &#123; struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode-&gt;val = val; newNode-&gt;next = NULL; return newNode;&#125;void splitList(struct ListNode* head) &#123; struct ListNode* current = head; int sequenceCount = 0; while (current != NULL &amp;&amp; sequenceCount &lt; 10) &#123; struct ListNode* sequenceHead = NULL; // 当前序列的头节点 struct ListNode* sequenceTail = NULL; // 当前序列的尾节点 struct ListNode* seen = NULL; while (current != NULL) &#123; if (sequenceTail == NULL || current-&gt;val &gt; sequenceTail-&gt;val) &#123; // 如果当前元素比序列的尾元素大，加入当前序列 if (seen == NULL || !contains(seen, current-&gt;val)) &#123; // 如果当前元素没有出现在已选择的序列中 if (sequenceTail == NULL) &#123; sequenceHead = current; &#125; else &#123; sequenceTail-&gt;next = current; &#125; sequenceTail = current; current = current-&gt;next; sequenceTail-&gt;next = NULL; &#125; &#125; // 若无法加入当前序列，则跳过 else &#123; current = current-&gt;next; &#125; &#125; printSequence(sequenceHead); // 打印当前序列 sequenceCount++; &#125;&#125;void printSequence(struct ListNode* head) &#123; struct ListNode* current = head; while (current != NULL) &#123; printf(&quot;%d &quot;, current-&gt;val); current = current-&gt;next; &#125; printf(&quot; &quot;);&#125;int contains(struct ListNode* seen, int val) &#123; while (seen != NULL) &#123; if (seen-&gt;val == val) &#123; return 1; // 表示集合中包含该元素 &#125; seen = seen-&gt;next; &#125; return 0; // 表示集合中不包含该元素&#125; 7. 树的结构 树结构 双亲表示法 孩子表示法 孩子兄弟表示法 子树结构的判定 1234567891011121314151617181920212223242526272829303132typedef struct TreeNode &#123; int val; struct TreeNode* left; struct TreeNode* right;&#125; TreeNode;// 判断树A的节点是否与树B相同bool isIdentical(TreeNode* rootA, TreeNode* rootB) &#123; if (rootA == NULL &amp;&amp; rootB == NULL) &#123; return true; &#125; if (rootA == NULL || rootB == NULL) &#123; return false; &#125; return (rootA-&gt;val == rootB-&gt;val) &amp;&amp; isIdentical(rootA-&gt;left, rootB-&gt;left) &amp;&amp; isIdentical(rootA-&gt;right, rootB-&gt;right);&#125;bool isSubtree(TreeNode* rootA, TreeNode* rootB) &#123; if (rootB == NULL) &#123; return true; &#125; if (rootA == NULL) &#123; return false; &#125; if (rootA-&gt;val == rootB-&gt;val &amp;&amp; isIdentical(rootA, rootB)) &#123; return true; &#125; return isSubtree(rootA-&gt;left, rootB) || isSubtree(rootA-&gt;right, rootB);&#125; 8.PV题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566semaphore mutex_stop = 1 //停车区semaphore stop_empty = m //停车区空位semaphore wash_empty = n //洗车区空位semaphore unclean = 0 //停车区未洗的semaphore clean = 0 //停车区已洗的semaphore mutex_clean = 1 //洗车区semaphore wait_clean = 0 //洗车区待洗的车semaphore has_clean = 0 //洗车区已洗的车 A()&#123; while(true)&#123; 客户的车来了 P(stop_empty) P(mutex_stop) 将未洗的车放进停车区 V(unclean) V(mutex_stop) &#125;&#125;B()&#123;\twhile(true)&#123; P(unclean) P(wash_empty) P(mutex_stop) P(mutex_clean) 停车区开进洗车区 V(mutex_stop) V(wait_clean) V(mutex_clean) &#125;&#125;C()&#123;\twhile(true)&#123; P(wait_clean) 洗车 V(has_clean) &#125;&#125;D()&#123;\twhile(true)&#123; P(has_clean) P(stop_empty) P(mutex_clean) P(mutex_stop) 从洗车区开进停车区 V(mutex_clean) V(mutex_stop) V(wash_empty) V(clean) &#125;&#125;E()&#123; while(true)&#123; P(clean) P(mutex_stop) 开给客户; V(mutex_stop) V(stop_empty) &#125;&#125;"},{"title":"搭建github-hexo博客","path":"/2024/11/24/搭建github-hexo博客/","content":"安装nodejs 部署GitHub-ssh添加ssh 降低温度"},{"title":"Hello World","path":"/2024/11/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]