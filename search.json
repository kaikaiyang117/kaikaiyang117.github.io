[{"title":"C++几种智能指针","path":"/2025/01/16/C-几种智能指针/","content":"智能指针作用：用于自动管理动态分配的内存，避免内存泄漏和悬空指针等问题。 C++ 提供了几种智能指针，用于自动管理动态分配的内存，避免内存泄漏和悬空指针等问题。以下是 C++ 中主要的几种智能指针及其特点： 1. std::unique_ptr 特点： 独占所有权：同一时间只能有一个 unique_ptr 指向一个对象。 不能复制，只能移动（通过 std::move）。 当 unique_ptr 被销毁时，它所管理的对象也会自动被销毁。 适用场景： 需要独占资源的场景。 替代原始指针，避免手动调用 delete。 示例： 12345678910111213#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42); std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // 输出 42 // auto ptr2 = ptr; // 错误：unique_ptr 不能复制 auto ptr2 = std::move(ptr); // 正确：转移所有权 if (!ptr) &#123; std::cout &lt;&lt; &quot;ptr 为空&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 2. std::shared_ptr 特点： 共享所有权：多个 shared_ptr 可以指向同一个对象。 使用引用计数来管理对象的生命周期，当引用计数为 0 时，对象会被自动销毁。 可以复制和移动。 适用场景： 需要多个指针共享同一个对象的场景。 需要自动管理对象生命周期的场景。 示例：12345678910#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42); std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 复制，引用计数增加 std::cout &lt;&lt; *ptr1 &lt;&lt; &quot; &quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 输出 42 42 std::cout &lt;&lt; &quot;引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // 输出 2 return 0;&#125; 3. std::weak_ptr 特点： 弱引用：不增加对象的引用计数。 需要从 shared_ptr 创建，用于观察对象而不影响其生命周期。 可以通过 lock() 方法获取一个 shared_ptr 来访问对象。 适用场景： 打破 shared_ptr 的循环引用。 需要观察对象但不需要拥有对象的场景。 示例：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared = std::make_shared&lt;int&gt;(42); std::weak_ptr&lt;int&gt; weak = shared; // 创建 weak_ptr if (auto locked = weak.lock()) &#123; // 尝试获取 shared_ptr std::cout &lt;&lt; *locked &lt;&lt; std::endl; // 输出 42 &#125; else &#123; std::cout &lt;&lt; &quot;对象已被销毁&quot; &lt;&lt; std::endl; &#125; shared.reset(); // 释放 shared_ptr if (auto locked = weak.lock()) &#123; std::cout &lt;&lt; *locked &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;对象已被销毁&quot; &lt;&lt; std::endl; // 输出此句 &#125; return 0;&#125; 4. std::auto_ptr（已弃用） 特点： C++98 引入的智能指针，具有独占所有权。 在 C++11 中被弃用，由 std::unique_ptr 替代。 存在潜在的所有权转移问题，容易导致错误。 示例：123456789101112#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::auto_ptr&lt;int&gt; ptr1(new int(42)); std::auto_ptr&lt;int&gt; ptr2 = ptr1; // 所有权转移，ptr1 变为空 if (!ptr1.get()) &#123; std::cout &lt;&lt; &quot;ptr1 为空&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl; // 输出 42 return 0;&#125; 5. std::shared_ptr 和 std::unique_ptr 的区别 特性 std::unique_ptr std::shared_ptr 所有权 独占 共享 复制 不支持 支持 移动 支持 支持 引用计数 无 有 性能 更高效 稍低（需要维护引用计数） 适用场景 独占资源的场景 共享资源的场景 总结 **std::unique_ptr**：用于独占资源，轻量且高效。 **std::shared_ptr**：用于共享资源，自动管理生命周期。 **std::weak_ptr**：用于打破循环引用或观察对象。 **std::auto_ptr**：已弃用，不建议使用。 根据具体需求选择合适的智能指针，可以显著提高代码的安全性和可维护性。&#96;** 观察者模式在智能指针的上下文中，通常是指使用 std::weak_ptr 来观察一个由 std::shared_ptr 管理的对象，而不增加其引用计数。这种模式可以安全地访问对象，同时避免影响对象的生命周期，特别适用于需要观察对象但不拥有对象的场景。 普通指针 vs 智能指针的生命周期对比 特性 普通指针 智能指针 内存分配 手动（new 或 malloc） 自动（std::make_unique 等） 内存释放 手动（delete 或 free） 自动（离开作用域时） 内存泄漏风险 高（容易忘记释放） 低（自动释放） 悬空指针风险 高（容易访问已释放的内存） 低（自动置空） 循环引用问题 无 std::shared_ptr 可能导致循环引用 线程安全性 无 std::shared_ptr 引用计数线程安全 性能开销 低 稍高（std::shared_ptr 有引用计数） 适用场景 需要精细控制内存的场景 需要自动管理内存的场景","categories":["C++开发"]},{"title":"线程池","path":"/2025/01/13/线程池/","content":"线程池问题通过使用线程池，我们可以有效降低多线程操作中任务申请和释放产生的性能消耗。特别是当我们每个线程的任务处理比较快时，系统大部分性能消耗都花在了线程创建以及释放中。 解决思想那既然是这样的话，何不在程序开始运行阶段提前创建好一堆线程，等我们需要用的时候只要去这一堆线程中领一个线程，用完了再放回去，等程序运行结束时统一释放这一堆线程呢？按照这个想法，线程池出现了。 线程池的四个组件 工作队列：负责处理任务 任务队列：负责存放将要执行的任务 线程池的池：接受任务 pthread_create中的回调函数：决定线程时工作还是休息","categories":["C++开发"]},{"title":"maven的原理和使用","path":"/2025/01/07/maven的原理和使用/","content":"作用Maven 也可被用于构建和管理各种项目 项目依赖参考教程","categories":["java开发"]},{"title":"博客上传指南","path":"/2025/01/06/博客上传指南/","content":"如何上传文章1.创建在博客目录下，打开命令行 1hexo new &quot;文章标题&quot; Hexo 会在source/_posts目录下创建一个新的 Markdown 文件，文件名是根据文章标题生成的，同时会自动添加一些基本的头部信息，如文章的创建日期、标题等。 然后使用markdown编辑文章 2.在本地查看并预览启动本地服务器，运行 1hexo server 访问地址http://localhost:4000,查看在本地的预览效果。 3.部署讲完成的博客,使用 1hexo deploy 部署在github上。 hexo常用指令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 针对stellar主题的尝试官方文档 1.增加文章的预览页面","categories":["博客网站搭建教程"]},{"path":"/2024/12/01/搭建github-hexo博客/检测/","content":"1判断环 1.1 拓扑排序针对无向图： 求出图中所有结点的度。 将所有&#x3D;&#x3D;度&#x3D;&#x3D; &lt;&#x3D; 1 的结点入队。 当队列不空时，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为一，则将相邻结点入队。 循环结束时判断已经访问的结点数是否等于 n。等于 n 说明全部结点都被访问过，无环；反之，则有环。 针对有向图： 求出图中所有结点的度。 将所有&#x3D;&#x3D;入度&#x3D;&#x3D; &#x3D; 0 的结点入队。 当队列不空时，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为一，则将相邻结点入队。 循环结束时判断已经访问的结点数是否等于 n。等于 n 说明全部结点都被访问过，无环；反之，则有环。 仿照拓扑排序 对于有向图的拓扑排序，kahn算法： 计算图中所有点的入度，把入度为0的点加入栈 如果栈非空： 取出栈顶顶点a，输出该顶点值，删除该顶点 从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈 如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列 1.2 DFS：使用 &#x3D;&#x3D;DFS&#x3D;&#x3D; 可以判断一个无向图和有向图中是否存在环。深度优先遍历图，如果在遍历的过程中，发现某个结点有一条边指向已访问过的结点，并且这个已访问过的结点不是上一步访问的结点，则表示存在环。 1.针对有向图： 环的判断需要关注图中是否&#x3D;&#x3D;存在回边&#x3D;&#x3D;，即从某个节点出发又返回到该节点。在DFS过程中，可以使用三种状态来标记节点： **未访问 (0)**：该节点还没有被访问过。 **正在访问 (1)**：该节点正在递归调用过程中，意味着DFS已经进入该节点，但尚未完成该节点的所有邻接点访问。 **已访问 (2)**：该节点及其所有邻接节点的DFS调用都已完成。 在DFS过程中，如果从当前节点的邻接节点出发回到一个正在访问 (1) 状态的节点，说明图中存在环。 针对无向图 对于无向图，环的判断稍微复杂一些，因为无向图的边是双向的，因此在DFS过程中，如果访问到一个已经访问过的节点，并且该节点不是DFS路径的父节点，就说明存在环。 1.3 并查集（Union-Find）并查集是一种用于处理连通性问题的数据结构，常用于无向图的环检测。在图中添加一条边时，使用并查集检查两个端点是否属于同一个集合。 如果两端点已经在同一个集合中，则添加这条边会形成环。 如果不在同一个集合中，则将它们合并。 2.递归建树 2.1 建树12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;struct Node &#123; int data; Node* left; Node* right;&#125;;void Insert(Node*&amp; root, int value) &#123; if (root == nullptr) &#123; root = new Node&#123;value, nullptr, nullptr&#125;; return; &#125; if (value &lt; root-&gt;data) &#123; Insert(root-&gt;left, value); &#125; else &#123; Insert(root-&gt;right, value); &#125;&#125;void Createbstree(Node*&amp; T, int L[], int N) &#123; //针对有序数组 if (N &lt;= 0) return; int mid = N / 2; Insert(T, L[mid]); Createbstree(T, L, mid); Createbstree(T, L + mid + 1, N - mid - 1); //针对无需数组 for (int i = 0; i &lt; N; ++i) &#123; Insert(T, L[i]); &#125;&#125; 2.2 合并二叉排序树123456789void MergeTrees(Node*&amp; T1, Node* T2) &#123; if (T2 == nullptr) return; MergeTrees(T1, T2-&gt;left); Insert(T1, T2-&gt;data); MergeTrees(T1, T2-&gt;right); &#125; void mergebstree(Node*&amp; T1, Node* T2) &#123; MergeTrees(T1, T2);&#125; 3.动态规划3.1抓娃娃 状态转移： 对于 n = 0，只有一种情况（即没有娃娃）。 对于 n = 1，只有一种情况（拿 1 个娃娃）。 对于 n = 2，有两种情况：要么拿两个 1，要么拿一个 2。 对于 n &gt; 2，我们可以通过以下两种方式来考虑： 如果第一次拿了 1 个娃娃，那么剩下的就是 n-1 个娃娃，问题转化为 n-1 的情况。 如果第一次拿了 2 个娃娃，那么剩下的就是 n-2 个娃娃，问题转化为 n-2 的情况。 因此，递推关系式为： ​ $f(n)&#x3D;f(n−1)+f(n−2)$ 其中 f(n) 表示有多少种方式分配 n 个娃娃。 4.贪心算法 题解： 5. 图 使用邻接表表示图，记录每个人被喜欢的次数。 使用 入度数组 来统计每个节点的被喜欢次数。 使用拓扑排序检测并剔除环。环状喜欢链会导致入度无法减少。 遍历 入度数组，找出被喜欢度最大的节点。 如果有多个节点被喜欢度相同，按字典序输出。 6 .链表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode &#123; int val; struct ListNode* next; struct ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;struct ListNode* createNode(int val) &#123; struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode-&gt;val = val; newNode-&gt;next = NULL; return newNode;&#125;void splitList(struct ListNode* head) &#123; struct ListNode* current = head; int sequenceCount = 0; while (current != NULL &amp;&amp; sequenceCount &lt; 10) &#123; struct ListNode* sequenceHead = NULL; // 当前序列的头节点 struct ListNode* sequenceTail = NULL; // 当前序列的尾节点 struct ListNode* seen = NULL; while (current != NULL) &#123; if (sequenceTail == NULL || current-&gt;val &gt; sequenceTail-&gt;val) &#123; // 如果当前元素比序列的尾元素大，加入当前序列 if (seen == NULL || !contains(seen, current-&gt;val)) &#123; // 如果当前元素没有出现在已选择的序列中 if (sequenceTail == NULL) &#123; sequenceHead = current; &#125; else &#123; sequenceTail-&gt;next = current; &#125; sequenceTail = current; current = current-&gt;next; sequenceTail-&gt;next = NULL; &#125; &#125; // 若无法加入当前序列，则跳过 else &#123; current = current-&gt;next; &#125; &#125; printSequence(sequenceHead); // 打印当前序列 sequenceCount++; &#125;&#125;void printSequence(struct ListNode* head) &#123; struct ListNode* current = head; while (current != NULL) &#123; printf(&quot;%d &quot;, current-&gt;val); current = current-&gt;next; &#125; printf(&quot; &quot;);&#125;int contains(struct ListNode* seen, int val) &#123; while (seen != NULL) &#123; if (seen-&gt;val == val) &#123; return 1; // 表示集合中包含该元素 &#125; seen = seen-&gt;next; &#125; return 0; // 表示集合中不包含该元素&#125; 7. 树的结构 树结构 双亲表示法 孩子表示法 孩子兄弟表示法 子树结构的判定 1234567891011121314151617181920212223242526272829303132typedef struct TreeNode &#123; int val; struct TreeNode* left; struct TreeNode* right;&#125; TreeNode;// 判断树A的节点是否与树B相同bool isIdentical(TreeNode* rootA, TreeNode* rootB) &#123; if (rootA == NULL &amp;&amp; rootB == NULL) &#123; return true; &#125; if (rootA == NULL || rootB == NULL) &#123; return false; &#125; return (rootA-&gt;val == rootB-&gt;val) &amp;&amp; isIdentical(rootA-&gt;left, rootB-&gt;left) &amp;&amp; isIdentical(rootA-&gt;right, rootB-&gt;right);&#125;bool isSubtree(TreeNode* rootA, TreeNode* rootB) &#123; if (rootB == NULL) &#123; return true; &#125; if (rootA == NULL) &#123; return false; &#125; if (rootA-&gt;val == rootB-&gt;val &amp;&amp; isIdentical(rootA, rootB)) &#123; return true; &#125; return isSubtree(rootA-&gt;left, rootB) || isSubtree(rootA-&gt;right, rootB);&#125; 8.PV题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566semaphore mutex_stop = 1 //停车区semaphore stop_empty = m //停车区空位semaphore wash_empty = n //洗车区空位semaphore unclean = 0 //停车区未洗的semaphore clean = 0 //停车区已洗的semaphore mutex_clean = 1 //洗车区semaphore wait_clean = 0 //洗车区待洗的车semaphore has_clean = 0 //洗车区已洗的车 A()&#123; while(true)&#123; 客户的车来了 P(stop_empty) P(mutex_stop) 将未洗的车放进停车区 V(unclean) V(mutex_stop) &#125;&#125;B()&#123;\twhile(true)&#123; P(unclean) P(wash_empty) P(mutex_stop) P(mutex_clean) 停车区开进洗车区 V(mutex_stop) V(wait_clean) V(mutex_clean) &#125;&#125;C()&#123;\twhile(true)&#123; P(wait_clean) 洗车 V(has_clean) &#125;&#125;D()&#123;\twhile(true)&#123; P(has_clean) P(stop_empty) P(mutex_clean) P(mutex_stop) 从洗车区开进停车区 V(mutex_clean) V(mutex_stop) V(wash_empty) V(clean) &#125;&#125;E()&#123; while(true)&#123; P(clean) P(mutex_stop) 开给客户; V(mutex_stop) V(stop_empty) &#125;&#125;"},{"title":"搭建github-hexo博客","path":"/2024/11/24/搭建github-hexo博客/","content":"安装nodejs 部署GitHub-ssh添加ssh 降低温度","categories":["博客网站搭建教程"]}]